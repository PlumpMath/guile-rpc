\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename guile-rpc.info
@settitle An ONC RPC Framework for Guile
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@set EDITION 1
@include version.texi


@ifinfo
@dircategory The Algorithmic Language Scheme
@direntry
* Guile RPC: (guile-rpc).      An ONC RPC Framework for Guile.
@end direntry

This file documents Guile-RPC.

Copyright @copyright{} 2007 Ludovic Court@`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title An ONC RPC Framework for Guile
@subtitle for Guile-RPC @value{VERSION}
@author Ludovic Courtès

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@c Updated for Guile-RPC @value{VERSION} @*
@value{UPDATED} @*

Copyright @copyright{} 2007 Ludovic Court@`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@contents

@c *********************************************************************
@node Top, Introduction, (dir), (dir)
@top An ONC RPC Framework for Guile

This document describes Guile-RPC version @value{VERSION}.  It was
last updated in @value{UPDATED-MONTH}.

@menu
* Introduction::                Overview of Guile-RPC
* Quick Start::                 Writing an RPC client in a glimpse
* API Reference::               Everything about Guile-RPC
* References::                  Useful documents
* Concept Index::               Concepts discussed in this document
* Function Index::              Index of Scheme procedures
@end menu


@c *********************************************************************
@node Introduction, Quick Start, Top, Top
@chapter Introduction

Guile-RPC is a framework for distributed programming under Guile.  It
is a pure Scheme implementation of the ONC RPC standard, i.e., the
``Open Network Computing'' Remote Procedure Call standard.  ONC RPC is
standardized by the Internet Engineering Task Force (IETF) as RFC
1831.  It is based on the External Data Representation standard (XDR),
known as RFC 4506 (@pxref{References}).

@cindex marshalling
@cindex distributed programming
Remote procedure calls allow programs on different, potentially remote
machines to interact together.  A @dfn{remote procedure call} is the
invocation of the procedure of a program located on a remote host (the
@dfn{RPC server}), as the name implies.  Doing so requires the
procedure arguments on the client-side to be encoded, or
@dfn{marshalled}, i.e., converted to a representation suitable for
transfer over the network.  On the server-side, upon reception of the
RPC, those arguments must be decoded or @dfn{unmarshalled}, i.e.,
converted back to a form that is directly understandable by the server
program---for instance, data using Scheme data types, should the
server program be written in Scheme.  The value returned by the RPC
server must be encoded and decoded similarly.

When using the ONC RPC protocol, the way data items are encoded is
dictated by the XDR standard.  This encoding has the advantage of
being particularly compact, allowing for relatively low bandwidth
requirements and fast implementations, especially compared to more
verbose RPC protocols such as XML-RPC and SOAP.

Guile-RPC provides an easy access to the ONC RPC protocol for the
Guile Scheme programmer.  In particular, it allows standard Scheme
types to be mapped to XDR data types, so that Scheme objects are
easily encoded to or decoded from XDR.

In order to use Guile-RPC, all that is needed is
@uref{http://www.gnu.org/software/guile/guile.html, GNU Guile 1.8}
along with the R6RS library package for Guile 1.8, known as
@code{guile-r6rs-libs}.


@c *********************************************************************
@node Quick Start, API Reference, Introduction, Top
@chapter Quick Start

Currently, Guile-RPC lacks a compiler for the XDR and RPC languages.
So one has to write data type and RPC definitions ``by hand'', using
the Guile-RPC's programming interface.  Hopefully, this should be
quite straightforward.

Consider the following RPC definitions:

@example
typedef struct
@{
  int          integer_part;
  unsigned int decimal_part;
@} result_t;

program ARITHMETIC_PROGRAM
@{
  version ARITHMETIC_VERSION
  @{
    /* Return the integer and decimal part of NUMBER.  */
    result_t split_number (double number) = 1;
  @} = 0;
@} = 80000;
@end example

This defines a simple RPC @dfn{interface} named @code{ARITHMETIC}
which contains only one procedure called @code{split_number ()}.  The
interface itself has a @dfn{program number} that identifies it (here,
80000).  Normally, program numbers below 20000000 (hexadecimal) are
assigned by Sun Microsystems, Inc. and thus should not be used unless
the number has been properly registered (@pxref{References, RFC 1831},
for details).  It also has a @dfn{version number} (here, 0) that is
user-defined and should be increased when the interface changes (e.g.,
when procedures are added, modified, etc.).  Finally, the procedure
@code{split_number ()} has a procedure number (here, 1) that allows it
to be distinguished from other procedures.

People vaguely familiar with the C programming language should have
guessed by now that this simple interface defines a procedure that
takes a double-precision floating-point number and returns a structure
that contains two fields.

Before actually creating a client or server for this interface, one
must define the types it uses.  To that end, one must first import the
relevant Guile-RPC modules:

@example
(use-modules (rpc xdr)
             (rpc xdr types))
@end example

Then, the @code{result_t} type must be defined:

@example
(define result-type
  (make-xdr-struct-type (list xdr-integer             ;; `integer_part'
                              xdr-unsigned-integer))) ;; `decimal_part'
@end example

Producing a client to invoke @code{split_number ()} is as simple as
this:

@example
(use-modules (rpc rpc))

(define invoke-split-number
  (make-synchronous-rpc-call 80000 0    ;; program and version
                             1          ;; procedure number
                             xdr-double ;; argument type
                             result-type))
@end example

Once this is done, invoking the procedure is as simple as this:

@example
(invoke-split-number 3.14 #x7777 socket)
@end example

@cindex transaction ID (xid)

The first argument to @code{invoke-split-number} is the argument of
@code{split_number ()}; the second argument is a transaction ID, i.e.,
an arbitrarily chosen number that identifies the remote procedure
call; the third argument should be an output port, typically one
bound to a connection to the RPC server:

@example
(define socket (socket PF_INET SOCK_STREAM 0))
(connect socket AF_INET INADDR_LOOPBACK 6666)
@end example

This example creates an IPv4 connection to the local host on port 6666
(@pxref{Network Sockets and Communication,,, guile, Guile Reference
Manual}).

On success, @code{invoke-split-number} returns a two-element list
where the first element corresponds to the @code{integer_part} field
of the result and the second element correspond to the
@code{decimal_part} field of the result, both represented as Scheme
exact integers.

More details about the XDR type definition as well as client and
server creation are available in the API reference (@pxref{API
Reference}).


@c *********************************************************************
@node API Reference, References, Quick Start, Top
@chapter API Reference

This section first details facilities available to manipulate XDR
types.  It then describes Scheme procedures that should be used to
build ONC RPC clients and servers.

@menu
* Implementation of XDR::       
* Implementation of ONC RPC::   
@end menu

@node Implementation of XDR, Implementation of ONC RPC, API Reference, API Reference
@section Implementation of XDR

This section describes how XDR types are represented in Guile-RPC, as
well as how one can encode Scheme values to XDR and decode XDR binary
data to Scheme values.

@menu
* XDR Type Representations::    Foundations.
* XDR Standard Data Types::     The XDR standard types.
* XDR Encoding and Decoding::   Encoding to and decoding from XDR.
@end menu

@node XDR Type Representations, XDR Standard Data Types, Implementation of XDR, Implementation of XDR
@subsection XDR Type Representations

@cindex XDR type objects

The XDR standard defines various basic data types and allows for the
definition of compound data types (``structs''), fixed-size and
variable-size arrays as well as ``unions''.  Fixed-size arrays and
structs can actually be thought as the same type: Their size if known
in advance and they are encoded as the succession of the data they
contain.  Thus, those types can be summarized as 4 great classes:
``basic'' types, variable-length arrays, structs and unions.

The @code{(rpc xdr)} module provides facilities to represent and
handle these classes of types which we describe below.

@deffn {Scheme Procedure} make-xdr-basic-type name size type-pred encoder decoder [vector-decoder]
This returns an @code{<xdr-basic-type>} object describing a type whose
encoding fits on @var{size} octets, and which is encoded/decoded using
the @var{encoder} and @var{decoder} procedures.  @var{type-pred}
should be a predicate checking the validity of an input Scheme value
for encoding into this type.  Optionally, @var{vector-decoder} can be
passed and should be a procedure that efficiently decodes sequences of
data items of this type (for instance, the vector decoder could use
the @code{bytevector->int-list} procedure of the @code{(r6rs
bytevector)} module to speed up decoding).

Users should normally not need to define new basic types since all the
basic types defined by XDR are already available in @code{(rpc xdr
types)} (@pxref{XDR Standard Data Types}).  Thus, we will not describe
its use further.
@end deffn

@deffn {Scheme Procedure} make-xdr-struct-type base-types
Return a new XDR struct type made of a sequence of XDR data items
whose types are listed in @var{base-types}.

Struct types encode from/decode to Scheme lists whose length is that
of @var{base-types}.
@end deffn

@deffn {Scheme Procedure} make-xdr-vector-type base-type max-element-count
Return an object describing an XDR variable-length array of elements
of types @var{base-type} (again, an XDR type object).  If
@var{max-element-count} is a number, then it describes the maximum
number of items of type @var{base-type} that are allow in actual
arrays of this type.  If @var{base-type} is @code{#f}, then arrays of
this type may contain up to 2^32 - 1 items of type @var{base-type}.

Vector types encode from/decode to Scheme vectors.  If
@var{max-element-count} is specified and a vector to be encoded
contains more than @var{max-element-count} elements, then an
@code{&xdr-vector-size-exceeded-error} error condition is raised.
Likewise, if XDR data to be decoded describes vectors larger than
@var{max-element-count}, this error condition is raised.
@end deffn

@deffn {Scheme Procedure} make-xdr-union-type discr-type discr/type-alist default-type
Return a new XDR discriminated union type, using @var{discr-type} as the
discriminant type (which must be a 32-bit basic type) and
@var{discr/type-alist} to select the ``arm'' type depending on the
discriminant value.  If no suitable value is found in @var{discr/type-alist}
and @var{default-type} is not @code{#f}, then default type is used as the arm
type.

Union types encode from/decode to Scheme pairs whose @code{car} is the
discriminant's value and whose @code{cdr} is the actual union value.
@end deffn

@deffn {Scheme Procedure} xdr-union-arm-type union discriminant
Return the type that should be used for @var{union}'s arm given
@var{discriminant} (a Scheme value).
@end deffn

It is often useful to know the size in octets it takes to encode a
given value according to an XDR type.  However, as we just saw, the
size of some XDR types (variable-length arrays and unions) cannot be
known in advance: The encoding size depends on the actual value to
encode.  The following procedure allow the computation of the size of
the XDR representation of some value.

@deffn {Scheme Procedure} xdr-type-size type value
Return the size (in octets) of @var{type} when applied to
@var{value}.  @var{type} must be an XDR type object returned by one of
the above procedures, while @var{value} should be a Scheme value
suitable for encoding with @var{type}.
@end deffn

The following section lists the standard XDR data types.


@node XDR Standard Data Types, XDR Encoding and Decoding, XDR Type Representations, Implementation of XDR
@subsection XDR Standard Data Types

All the basic data types defined by XDR are defined in the @code{(rpc
xdr types)} module.

@defvr {Scheme Variable} xdr-integer
@defvrx {Scheme Variable} xdr-unsigned-integer
@defvrx {Scheme Variable} xdr-hyper-integer
@defvrx {Scheme Variable} xdr-unsigned-hyper-integer
XDR's 32-bit and 64-bit signed and unsigned integer types.  This type
decodes to/encodes from Scheme exact numbers.
@end defvr

@defvr {Scheme Variable} xdr-float
@defvrx {Scheme Variable} xdr-double
32-bit and 64-bit IEEE-754 floating point numbers.  This type decodes
to/encodes from Scheme inexact numbers.  Note that XDR also defines a
``quadruple-precision floating point type'' (i.e., 128-bit long) that
is currently not available (FIXME).
@end defvr

@defvr {Scheme Variable} xdr-void
The ``void'' type that yields zero bits.  Any Scheme value is suitable
as an input when encoding with this type.  When decoding this type,
the @code{%void} value (which may be compared via @code{eq?}) is
returned.
@end defvr

XDR provides support for ``enumerations'', similar to that found in C.
An enumeration type maps symbols to integers and are actually encoded
as 32-bit integers.

@deffn {Scheme Procedure} make-xdr-enumeration name enum-alist
Return an enumeration type that obeys the symbol-integer mapping
provided in @var{enum-alist} which should be a list of symbol-integer
pairs.  The returned type decodes to/encodes from Scheme symbols, as
provided in @var{enum-alist}.  Upon decoding/encoding of an
enumeration, an @code{&xdr-enumeration-error} is raised if an
incorrect value (i.e., one not listed in @var{enum-alist}) is found.
@end deffn

@deffn {Scheme Variable} xdr-boolean
XDR's boolean type which is an enumeration.  It encodes to/decodes
from Scheme symbols @code{TRUE} and @code{FALSE}.
@end deffn

Several fixed-size and variable-size are predefined in the standard.

@deffn {Scheme Procedure} make-xdr-fixed-length-opaque-array size
Return a fixed-length ``opaque'' array of @var{size} octets.  An
opaque array is simply a sequence of octets.

The returned XDR type object is actually an @code{<xdr-struct-type>}
object.  Thus, it encodes from/decodes to Scheme lists of exact
integers.  Conversion to a Scheme string, if needed, is left to the
user.
@end deffn

@deffn {Scheme Procedure} make-xdr-variable-length-opaque-array limit
Return a variable-length opaque array.  As for
@code{make-xdr-vector-type} (@pxref{XDR Type Representations}),
@var{limit} can be either a number specifying the maximum number of
elements that can be held by the created type, or @code{#f} in which
case the variable-length array can hold up to 2^32 - 1 octets.

The returned XDR type object is actually an @code{<xdr-vector-type>}
object.  Thus, it encodes from/decodes to Scheme vectors of exact
integers.
@end deffn

@deffn {Scheme Procedure} make-xdr-string limit
This is a synonym of @code{make-xdr-variable-length-opaque-array}
since XDR's string type actually represents ASCII strings, i.e.,
sequences of octets.
@end deffn

@defvr {Scheme Variable} xdr-variable-length-opaque-array
@defvrx {Scheme Variable} xdr-string
These convenience variables contain the unlimited variable-length
opaque array.
@end defvr


@node XDR Encoding and Decoding,  , XDR Standard Data Types, Implementation of XDR
@subsection XDR Encoding and Decoding

The following primitives are exported by the @code{(rpc xdr)} module.
They implement the encoding of Scheme values to XDR data types, and
the decoding of binary XDR data to Scheme values.  The exact mapping
between XDR data types and Scheme data types has been discussed
earlier.

@deffn {Scheme Procedure} xdr-encode! bv index type value
Encode @var{value} (a suitable Scheme value), using XDR type
@var{type}, into bytevector @var{bv} at @var{index}.  Return the index
where encoding ended.

@var{bv} should be an R6RS bytevector large enough to hold the XDR
representation of value according to @var{type}.  To that end, users
may rely on @code{xdr-type-size} (@pxref{XDR Type Representations}).

Error conditions sub-classing @code{&xdr-error} may be raised during
encoding.  The exact exceptions that may be raised are type-dependent
and have been discussed in the previous sections.
@end deffn

@deffn {Scheme Procedure} xdr-decode type port
Decode from @var{port} (a binary input port) a value of XDR type
@var{type}.  Return the decoded value.

Error conditions sub-classing @code{&xdr-error} may be raised during
encoding.  The exact exceptions that may be raised are type-dependent
and have been discussed in the previous sections.
@end deffn


@node Implementation of ONC RPC,  , Implementation of XDR, API Reference
@section Implementation of ONC RPC

@menu
* Building an RPC Client::      
* Building an RPC Server::      
* ONC RPC Message Types::       
@end menu

@node Building an RPC Client, Building an RPC Server, Implementation of ONC RPC, Implementation of ONC RPC
@subsection Building an RPC Client

Basic building blocks for the creation of RPC clients are provided by
the @code{(rpc rpc)} module.  The easiest way to build an RPC client
is through @code{make-synchronous-rpc-call}.

@deffn {Scheme Procedure} make-synchronous-rpc-call program version procedure arg-type result-type
Return a procedure that may be applied to a list of arguments,
transaction ID (any unsigned number representable on 32 bits), and I/O
port, to make a synchronous RPC call to the remote procedure numbered
@var{procedure} in @var{program}, version @var{version}.  On success,
the invocation result is eventually returned.  Otherwise, an error
condition is raised.  @var{arg-type} and @var{result-type} should be
XDR type objects (@pxref{XDR Type Representations}).

Error conditions that may be raised include those related to XDR
encoding and decoding (@pxref{XDR Encoding and Decoding}), as well as
RPC-specific error conditions inheriting from @code{&rpc-error} (i.e.,
conditions that pass the @code{rpc-error?} predicate).  These are
detailed in @ref{ONC RPC Message Types}.
@end deffn

@node Building an RPC Server, ONC RPC Message Types, Building an RPC Client, Implementation of ONC RPC
@subsection Building an RPC Server

@node ONC RPC Message Types,  , Building an RPC Server, Implementation of ONC RPC
@subsection ONC RPC Message Types

@cindex @code{rpc_msg} struct type

The @code{(rpc rpc types)} module provides a representation of the
various XDR types defined in the standard to represent RPC messages
(@pxref{References}).  We only describe the most important one as well
as procedures from the @code{(rpc rpc)} module that help use it.

@defvr {Scheme Variable} rpc-message
This variable contains a XDR struct type representing all possible RPC
messages---the @code{rpc_msg} struct type defined in RFC 1831.  By
``rpc message'' we mean the header that is transmitted before the
actual procedure argument to describe the procedure call being made.

Roughly, this header contains a transaction ID allowing clients to
match call/reply pairs, plus information describing either the call or
the reply being made.  Calls essentially contain a program, version
and procedure numbers.  Replies, on the other hand, can be more
complex since they can describe a large class of errors.
@end defvr

@defvr {Scheme Variable} rpc-message-type
This variable is bound to an XDR enumeration.  Its two possible values
are @code{CALL} and @code{REPLY} (both represented in Scheme using
symbols), denoting a procedure call and a reply to a procedure call,
respectively.
@end defvr

@deffn {Scheme Procedure} make-rpc-message xid type args ...
Return an @code{rpc-message} datum.  @var{type} should be either
@code{CALL} or @code{REPLY} (the two values of the
@code{rpc-message-type} enumeration).  The arguments @var{args} are
message-type-specific.  For example, a message denoting a procedure
call to procedure number 5 of version 1 of program 77 can be created
as follows:

@example
(define my-call-msg
  (make-rpc-message #x123 ;; the transaction ID
                    'CALL ;; the message type
                    77 1 5))
@end example

It can then be encoded in the usual way (@pxref{XDR Encoding and
Decoding}):

@example
(let* ((size (xdr-type-size rpc-message my-call-msg))
       (bv   (make-bytevector size)))
  (xdr-encode! bv 0 rpc-message my-call-msg)
  ;;; ...
  )
@end example

Likewise, a reply message denoting a successful RPC call can be
produced as follows:

@example
(make-rpc-message xid 'REPLY 'MSG_ACCEPTED 'SUCCESS)
@end example

It is worth noting that in practice, ``messages'' of type
@var{rpc-message} are followed by additional data representing either
the procedure call arguments (if the message is a @code{CALL} message)
or the procedure return value (if the message is a @code{REPLY}
message).
@end deffn

@deffn {Scheme Procedure} assert-successful-reply rpc-msg xid
Return true if @var{rpc-msg} (an RPC message as returned by a previous
@code{(xdr-decode rpc-message port)} call) is a valid reply for the
invocation labeled with transaction ID @var{xid} indicating that it
was accepted.  If @var{xid} is @code{#t}, any reply transaction ID is
accepted and it is returned (provided the rest of the message denotes
an accepted message).  On failure, an appropriate error condition is
raised.

The error conditions that may be raised obey @code{rpc-error?} and
@code{rpc-call-error?}.  More precisely, error conditions include the
following:

@table @code
@item rpc-program-unavailable-error?
If @var{rpc-msg} denotes the fact that the program requested by the
corresponding RPC call is not available.

@item rpc-program-mismatch-error?
If the corresponding RPC call requested a program version that is not
available.  The procedures
@code{rpc-program-mismatch-error:low-version} and
@code{rpc-program-mismatch-error:high-version} return, respectively,
the lowest and highest version numbers supported by the remote server.

@item rpc-procedure-unavailable-error?
If the corresponding RPC call requested a procedure that is not
available.

@item rpc-garbage-arguments-error?
If the remote server failed to decode the procedure arguments.

@item rpc-system-error?
If the remote server failed to allocate enough memory for argument
decoding, for instance.

@end table
@end deffn


@c *********************************************************************
@node References, Concept Index, API Reference, Top
@chapter References

@table @code
@item RFC 1831
R. Srinivasan et al., @uref{http://tools.ietf.org/html/rfc1831,``RPC:
Remote Procedure Call Protocol Specification Version 2''}, August
1995.
@item RFC 4506
M. Eisler et al., @uref{http://tools.ietf.org/html/rfc4506, ``XDR:
External Data Representation Standard''}, May 2006.
@end table


@c *********************************************************************
@node Concept Index, Function Index, References, Top
@unnumbered Concept Index
@printindex cp

@node Function Index,  , Concept Index, Top
@unnumbered Function Index
@printindex fn


@bye

@ignore
;;; arch-tag: 412a400f-ccbb-42d8-97a2-036301f92235
@end ignore

@c Local Variables:
@c ispell-local-dictionary: "american"
@c End:

