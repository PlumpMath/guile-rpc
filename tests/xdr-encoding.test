;;; Encoding/decoding of XDR data.                    -*- Scheme -*-
;;;
;;; Guile-RPC --- Implementation of R6RS standard libraries.
;;; Copyright (C) 2007  Ludovic Courtès <ludovic.courtes@laas.fr>
;;;
;;; Guile-RPC is free software; you can redistribute it and/or
;;; modify it under the terms of the GNU Lesser General Public
;;; License as published by the Free Software Foundation; either
;;; version 2.1 of the License, or (at your option) any later version.
;;;
;;; Guile-RPC is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;; Lesser General Public License for more details.
;;;
;;; You should have received a copy of the GNU Lesser General Public
;;; License along with Guile-RPC; if not, write to the Free Software
;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

(define-module (tests xdr-encoding)
  :use-module (rpc xdr)
  :use-module (rpc xdr types)
  :use-module (r6rs bytevector)
  :use-module (srfi srfi-34)
  :use-module (srfi srfi-35)
  :use-module (srfi srfi-64))


;;;
;;; Encoding/decoding.
;;;

(test-begin "encoding+decoding")

(define bv (make-bytevector 123))

;; XXX: srfi-64's `test-error' doesn't work with Guile so we use our own
;; trick.
(define %error-raised (list 'error))

(test-equal "integer" (values 123 4)
            (begin
              (xdr-encode! bv 0 xdr-integer 123)
              (xdr-decode bv 0 xdr-integer)))

(test-equal "integer (shifted)" (values 123 14)
            (begin
              (xdr-encode! bv 10 xdr-integer 123)
              (xdr-decode bv 10 xdr-integer)))

(test-equal "vector" (values (vector 1 2 3 4) 20)
            (let ((v (make-xdr-vector-type xdr-integer)))
              (xdr-encode! bv 0 v (vector 1 2 3 4))
              (xdr-decode bv 0 v)))

(test-equal "struct" (values (list 1 2 3.0) 20)
            (let ((s (make-xdr-struct-type (list xdr-integer
                                                 xdr-hyper-integer
                                                 xdr-double))))
              (xdr-encode! bv 0 s (list 1 2 3.0))
              (xdr-decode bv 0 s)))

(test-equal "enumeration" (values 'one 4)
            (let ((e (make-xdr-enumeration 'ordinals
                                           '((one . 1) (two . 2)))))
              (xdr-encode! bv 0 e 'one)
              (xdr-decode bv 0 e)))

(test-eq    "invalid enumeration (encoding)" %error-raised
            (guard (c ((xdr-type-error? c) %error-raised))
              (let ((e (make-xdr-enumeration 'ordinals
                                             '((one . 1) (two . 2)))))
                (xdr-encode! bv 0 e 'invalid)
                #f)))

(test-eq    "invalid enumeration (decoding)" %error-raised
            (guard (c ((xdr-enumeration-error? c) %error-raised))
              (let ((e (make-xdr-enumeration 'ordinals
                                             '((one . 1) (two . 2)))))
                (bytevector-u32-set! bv 0 777 %xdr-endianness)
                (xdr-decode bv 0 e))))

(test-equal "boolean" (values 'TRUE 4)
            (begin
              (xdr-encode! bv 0 xdr-boolean 'TRUE)
              (xdr-decode bv 0 xdr-boolean)))

(test-equal "union (1)" (values (cons 1 77) 8)
            (let* ((o (make-xdr-fixed-length-opaque-array 77))
                   (u (make-xdr-union-type xdr-integer
                                           `((1 . ,xdr-integer)
                                             (2 . ,o))
                                           #f)))
              (xdr-encode! bv 0 u (cons 1 77))
              (xdr-decode bv 0 u)))

(test-equal "union (2)" (values (cons 2 (make-list 77 255)) (+ 4 77))
            (let* ((o (make-xdr-fixed-length-opaque-array 77))
                   (u (make-xdr-union-type xdr-integer
                                           `((1 . ,xdr-integer)
                                             (2 . ,o))
                                           #f)))
              (xdr-encode! bv 0 u (cons 2 (make-list 77 255)))
              (xdr-decode bv 0 u)))

(test-equal "union (default)" (values (cons 55 7777) (+ 4 8))
            (let ((u (make-xdr-union-type xdr-integer
                                           `((1 . ,xdr-integer))
                                           xdr-hyper-integer)))
              (xdr-encode! bv 0 u (cons 55 7777))
              (xdr-decode bv 0 u)))

(test-equal "invalid union (encoding)" %error-raised
            (guard (c ((xdr-type-error? c) %error-raised))
              (let ((u (make-xdr-union-type xdr-integer
                                           `((1 . ,xdr-integer))
                                           #f)))
                (xdr-encode! bv 0 u (cons 33 ;; invalid discriminant
                                          'some-value))
                #f)))

(test-equal "invalid union (decoding)" %error-raised
            (guard (c ((xdr-type-error? c) %error-raised))
              (let ((u (make-xdr-union-type xdr-integer
                                           `((1 . ,xdr-integer))
                                           #f)))
                (bytevector-u32-set! bv 0 777 %xdr-endianness)
                (xdr-decode bv 0 u)
                #f)))

(test-equal "fixed-length opaque array" (values (make-list 10 77) 10)
            (let ((o (make-xdr-fixed-length-opaque-array 10)))
              (xdr-encode! bv 0 o (make-list 10 77))
              (xdr-decode bv 0 o)))

(test-equal "variable-length opaque array" (values (make-vector 10 77) 14)
            (let ((o xdr-variable-length-opaque-array))
              (xdr-encode! bv 0 o (make-vector 10 77))
              (xdr-decode bv 0 o)))

(test-equal "complex" (values (list 1.0 (vector -1 -2 -3 -4) 2.0)
                              36)
            (let* ((v (make-xdr-vector-type xdr-integer))
                   (s (make-xdr-struct-type (list xdr-double v
                                                  xdr-double))))
              (xdr-encode! bv 0 s (list 1.0 (vector -1 -2 -3 -4)
                                        2.0))
              (xdr-decode bv 0 s)))

(test-end "encoding+decoding")

(exit (= (test-runner-fail-count (test-runner-current)) 0))

;;; arch-tag: 3f929c58-25ef-4582-a90b-ccb28d0a39c7
